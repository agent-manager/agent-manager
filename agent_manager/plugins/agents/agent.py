"""Abstract base class for AI agent plugins (V2 interface)."""

import fnmatch
from abc import ABC, abstractmethod
from collections.abc import Callable
from pathlib import Path
from typing import Any

from agent_manager.core import MergerRegistry
from agent_manager.output import MessageType, VerbosityLevel, message


class AbstractAgent(ABC):
    """Base class for AI agent plugins with hierarchical configuration merging.

    V2 interface: agents receive a base_directory and a list of repos.
    The scope system has been removed.
    """

    @property
    @abstractmethod
    def agent_subdirectory(self) -> str:
        """The subdirectory name this agent manages (e.g. '.claude', '.cursor').

        This name is used both to discover files in repos and to determine
        where merged output is written under the target directory.
        """

    # Default files/directories to exclude when discovering configs
    BASE_EXCLUDE_PATTERNS = [
        ".git",
        ".gitignore",
        "__pycache__",
        "*.pyc",
        ".DS_Store",
        "README.md",
        "LICENSE",
        ".venv",
        "venv",
        "env",
        "node_modules",
        ".pytest_cache",
        ".ruff_cache",
        "*.egg-info",
    ]

    # Default root-level files to discover from repositories
    BASE_ROOT_LEVEL_FILES = ["AGENTS.md"]

    def __init__(self):
        """Initialize the agent with hook registries and merger registry."""
        self.pre_merge_hooks: dict[str, Callable] = {}
        self.post_merge_hooks: dict[str, Callable] = {}

        self.exclude_patterns = self.BASE_EXCLUDE_PATTERNS.copy()
        self.exclude_patterns.extend(self.get_additional_excludes())

        self.merger_registry = MergerRegistry()
        self.register_default_mergers()

        self._register_default_hooks()
        self.register_hooks()

    def register_default_mergers(self) -> None:
        """Register built-in mergers for common file types."""
        from agent_manager.agent_manager import create_default_merger_registry

        default_registry = create_default_merger_registry()
        self.merger_registry.filename_mergers = (
            default_registry.filename_mergers.copy()
        )
        self.merger_registry.extension_mergers = (
            default_registry.extension_mergers.copy()
        )
        self.merger_registry.default_merger = default_registry.default_merger

    def get_agent_name(self) -> str:
        """Get the display name for this agent.

        Returns the agent_subdirectory without the leading dot.

        Returns:
            Agent display name (e.g., "claude", "cursor")
        """
        return self.agent_subdirectory.lstrip(".")

    # ------------------------------------------------------------------
    # Hooks
    # ------------------------------------------------------------------
    def _register_default_hooks(self) -> None:
        """Register default hooks common to all agents."""
        self.pre_merge_hooks["*.md"] = self._clean_markdown
        self.post_merge_hooks["*"] = self._add_metadata_header

    def register_hooks(self) -> None:  # noqa: B027
        """Register agent-specific hooks for pre/post merge processing.

        Override this method to register additional hooks.
        """

    def _clean_markdown(
        self, content: str, repo_name: str, file_path: Path
    ) -> str:
        """Clean up markdown content before merging."""
        content = content.rstrip() + "\n"
        message(
            f"    Cleaned markdown from {repo_name}",
            MessageType.DEBUG,
            VerbosityLevel.DEBUG,
        )
        return content

    def _add_metadata_header(
        self, content: str, file_name: str, sources: list[str]
    ) -> str:
        """Add metadata header to merged files."""
        file_lower = file_name.lower()

        if file_lower.endswith(".json"):
            return content

        if file_lower.endswith(
            (
                ".yaml", ".yml", ".txt", ".py", ".sh",
                ".cursorrules", ".clinerules",
            )
        ):
            comment_start = "# "
            comment_end = ""
        elif file_lower.endswith(
            (".md", ".markdown", ".html", ".xml")
        ):
            comment_start = "<!-- "
            comment_end = " -->"
        else:
            comment_start = "# "
            comment_end = ""

        agent_name = self.get_agent_name()
        header = (
            f"{comment_start}Generated by agent-manager "
            f"({agent_name} agent){comment_end}\n"
        )
        header += f"{comment_start}File: {file_name}{comment_end}\n"
        header += (
            f"{comment_start}Sources: "
            f"{' â†’ '.join(sources)}{comment_end}\n"
        )
        header += (
            f"{comment_start}Hierarchy: {sources[0]} (lowest) to "
            f"{sources[-1]} (highest priority){comment_end}\n\n"
        )
        return header + content

    # ------------------------------------------------------------------
    # Excludes & root-level file discovery
    # ------------------------------------------------------------------
    def get_additional_excludes(self) -> list[str]:
        """Get agent-specific exclude patterns.

        Returns:
            List of additional patterns to exclude (default: empty list)
        """
        return []

    def get_additional_root_level_files(self) -> list[str]:
        """Get additional root-level files beyond BASE_ROOT_LEVEL_FILES.

        Override to add agent-specific root-level files.

        Returns:
            List of filenames to discover at repository root
        """
        return []

    def _get_root_level_files(self) -> list[str]:
        """Get complete list of root-level files to discover.

        Combines BASE_ROOT_LEVEL_FILES with get_additional_root_level_files().
        """
        if not hasattr(self, "_cached_root_level_files"):
            self._cached_root_level_files = (
                self.BASE_ROOT_LEVEL_FILES
                + self.get_additional_root_level_files()
            )
        return self._cached_root_level_files

    # ------------------------------------------------------------------
    # File discovery
    # ------------------------------------------------------------------
    def _discover_files(self, repo_path: Path) -> list[Path]:
        """Discover configuration files from a repository.

        Searches for:
        1. Root-level files (AGENTS.md, CLAUDE.md, etc.)
        2. Agent subdirectory files (repo/<agent_subdirectory>/...)

        Root-level files sort first so subdirectory files can override them.

        Args:
            repo_path: Path to the repository

        Returns:
            Sorted list of configuration file paths
        """
        found_files: list[Path] = []

        # Root-level files
        for filename in self._get_root_level_files():
            file_path = repo_path / filename
            if file_path.exists() and file_path.is_file():
                found_files.append(file_path)

        # Agent subdirectory files
        agent_repo_dir = repo_path / self.agent_subdirectory
        if agent_repo_dir.exists() and agent_repo_dir.is_dir():
            for item in agent_repo_dir.rglob("*"):
                if item.is_dir():
                    continue
                if any(
                    fnmatch.fnmatch(item.name, p)
                    for p in self.exclude_patterns
                ):
                    continue
                found_files.append(item)

        def sort_key(path: Path) -> tuple:
            is_subdirectory = path.parent != repo_path
            return (is_subdirectory, path.name)

        return sorted(found_files, key=sort_key)

    # ------------------------------------------------------------------
    # Initialize / Update / Merge
    # ------------------------------------------------------------------
    def _initialize(self, output_dir: Path) -> None:
        """Ensure the output directory exists.

        Override for agent-specific initialization (e.g. running SDK commands).

        Args:
            output_dir: The directory to ensure exists
        """
        if output_dir.exists():
            message(
                f"{self.get_agent_name()} directory already exists: "
                f"{output_dir}",
                MessageType.DEBUG,
                VerbosityLevel.DEBUG,
            )
            return

        message(
            f"Initializing {self.get_agent_name()} directory: {output_dir}",
            MessageType.INFO,
            VerbosityLevel.EXTRA_VERBOSE,
        )
        output_dir.mkdir(parents=True, exist_ok=True)
        message(
            f"Created {output_dir}",
            MessageType.SUCCESS,
            VerbosityLevel.ALWAYS,
        )

    def update(
        self,
        repos: list[dict[str, Any]],
        base_directory: Path,
        merger_settings: dict[str, Any] | None = None,
    ) -> None:
        """Update agent configuration in the given base directory.

        Args:
            repos: Ordered list of repo entries (lowest to highest priority).
                   Each must have 'name' and 'repo' keys.
            base_directory: Resolved target directory (e.g. Path.home()).
            merger_settings: Optional dict of per-merger settings from config.
        """
        output_dir = base_directory / self.agent_subdirectory
        self._initialize(output_dir)
        self.merge_configurations(repos, base_directory, merger_settings)

    def merge_configurations(
        self,
        repos: list[dict[str, Any]],
        base_directory: Path,
        merger_settings: dict[str, Any] | None = None,
    ) -> None:
        """Merge configuration files from repos into the base directory.

        Root-level files (AGENTS.md etc.) are written to base_directory.
        Agent subdirectory files are written to base_directory/<agent_subdirectory>.

        Args:
            repos: Ordered list of repo entries (lowest to highest priority).
            base_directory: Resolved target directory.
            merger_settings: Optional per-merger settings.
        """
        if merger_settings is None:
            merger_settings = {}

        message(
            f"\n=== Merging {self.get_agent_name()} configurations ===",
            MessageType.NORMAL,
            VerbosityLevel.ALWAYS,
        )
        message(
            f"Output: {base_directory}",
            MessageType.INFO,
            VerbosityLevel.VERBOSE,
        )

        # file_key -> (content, source_names)
        merged_files: dict[str, tuple[str, list[str]]] = {}

        for entry in repos:
            name = entry["name"]
            repo = entry["repo"]
            repo_path = repo.get_path()

            message(
                f"Processing '{name}' repository...",
                MessageType.INFO,
                VerbosityLevel.EXTRA_VERBOSE,
            )

            if not repo_path.exists():
                message(
                    f"  Repository path does not exist: {repo_path}",
                    MessageType.WARNING,
                    VerbosityLevel.ALWAYS,
                )
                continue

            files = self._discover_files(repo_path)
            if not files:
                message(
                    f"  No configuration files found in '{name}'",
                    MessageType.NORMAL,
                    VerbosityLevel.ALWAYS,
                )
                continue

            message(
                f"  Found {len(files)} file(s)",
                MessageType.DEBUG,
                VerbosityLevel.DEBUG,
            )

            agent_repo_dir = repo_path / self.agent_subdirectory

            for file_path in files:
                # Determine the file key (relative output path)
                try:
                    relative_path = file_path.relative_to(agent_repo_dir)
                    file_key = str(
                        Path(self.agent_subdirectory) / relative_path
                    )
                except ValueError:
                    # Root-level file (e.g. AGENTS.md)
                    file_key = file_path.name

                try:
                    content = file_path.read_text()
                    message(
                        f"    Processing: {file_key}",
                        MessageType.DEBUG,
                        VerbosityLevel.DEBUG,
                    )

                    # Pre-merge hook
                    content = self._run_hook(
                        self.pre_merge_hooks, file_key,
                        content, name, file_path,
                    )

                    if file_key in merged_files:
                        existing_content, sources = merged_files[file_key]
                        merger_class = self.merger_registry.get_merger(
                            file_path
                        )
                        settings = merger_settings.get(
                            merger_class.__name__, {}
                        )
                        merged_content = merger_class.merge(
                            existing_content, content,
                            name, sources, **settings,
                        )
                        sources.append(name)
                        merged_files[file_key] = (merged_content, sources)
                    else:
                        merged_files[file_key] = (content, [name])

                except Exception as e:
                    message(
                        f"    Could not process {file_key}: {e}",
                        MessageType.WARNING,
                        VerbosityLevel.ALWAYS,
                    )

            message(
                f"  Processed '{name}'",
                MessageType.SUCCESS,
                VerbosityLevel.ALWAYS,
            )

        # Write merged files
        if merged_files:
            message(
                f"\nWriting {len(merged_files)} merged file(s)...",
                MessageType.NORMAL,
                VerbosityLevel.ALWAYS,
            )

            for file_key, (content, sources) in merged_files.items():
                content = self._run_hook(
                    self.post_merge_hooks, file_key,
                    content, None, None, sources,
                )

                output_path = base_directory / file_key
                try:
                    output_path.parent.mkdir(parents=True, exist_ok=True)
                    output_path.write_text(content)
                    message(
                        f"  Wrote {file_key} "
                        f"(from {len(sources)} source(s): "
                        f"{', '.join(sources)})",
                        MessageType.SUCCESS,
                        VerbosityLevel.ALWAYS,
                    )
                except Exception as e:
                    message(
                        f"  Failed to write {file_key}: {e}",
                        MessageType.ERROR,
                        VerbosityLevel.ALWAYS,
                    )
        else:
            message(
                "No configuration files found in any repository",
                MessageType.WARNING,
                VerbosityLevel.ALWAYS,
            )

        message(
            "\nConfiguration merge complete!",
            MessageType.SUCCESS,
            VerbosityLevel.ALWAYS,
        )

    def _run_hook(
        self,
        hooks: dict[str, Callable],
        file_name: str,
        content: str,
        repo_name: str | None,
        file_path: Path | None,
        sources: list[str] | None = None,
    ) -> str:
        """Run registered hooks for a file pattern.

        Args:
            hooks: Hook registry to search
            file_name: Name/key of the file
            content: Current content
            repo_name: Repo name (for pre-merge hooks, None for post-merge)
            file_path: Path to source file (None for post-merge)
            sources: List of source names (for post-merge hooks)

        Returns:
            Possibly modified content
        """
        for pattern, hook_func in hooks.items():
            if fnmatch.fnmatch(file_name, pattern):
                try:
                    if sources is not None:
                        content = hook_func(content, file_name, sources)
                    else:
                        content = hook_func(content, repo_name, file_path)
                except Exception as e:
                    message(
                        f"  Hook error for {file_name} "
                        f"(pattern: {pattern}): {e}",
                        MessageType.WARNING,
                        VerbosityLevel.ALWAYS,
                    )
        return content
